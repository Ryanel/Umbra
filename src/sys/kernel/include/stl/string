#pragma once

#include <stddef.h>
#include <string.h>

namespace std {

class string {
   public:
    string() : m_buffer(nullptr), m_size(0) {}
    string(const char* str) : string(str, strlen(str)) {}
    string(const string& s) : string(s.m_buffer, s.m_size) {}

    string(const char* str, size_t sz) {
        size_t orig_size = sz;
        m_size           = get_buffer_size(orig_size);
        m_buffer         = new char[m_size];

        strncpy(m_buffer, str, orig_size);
        m_buffer[orig_size] = 0;  // Null terminated, always.
    }

    string& operator=(string&& s) {
        clean();
        m_buffer   = s.m_buffer;
        m_size     = s.m_size;
        s.m_buffer = nullptr;
        return *this;
    }

    // Copy assignment
    string& operator=(const string& s) {
        clean();
        m_size           = s.m_size;
        size_t buff_size = (m_size + 1) > min_size ? (m_size + 1) : min_size;
        m_buffer         = new char[buff_size];
        strncpy(m_buffer, s.m_buffer, s.size() + 1);
        return *this;
    }

    char& at(size_t i) {
        assert(m_buffer != nullptr);
        assert(i < m_size);
        return m_buffer[i];
    }

    char& operator[](size_t i) { return m_buffer[i]; }

    ~string() { clean(); }

    // Utility functions
    string substr(size_t start, size_t end = npos) const {
        if (end == npos) { end = size(); }

        string sub(m_buffer + start);
        sub[end - start] = 0;
        return sub;
    }

    size_t find(char c) const {
        for (size_t i = 0; i < size(); i++) {
            if (m_buffer[i] == c) { return i; }
        }
        return npos;
    }

    // Data functions
    size_t size() const { return strlen(m_buffer); }
    size_t length() const { return strlen(m_buffer); }

    char const* data() { return m_buffer; }
    char const* data() const { return m_buffer; }

    constexpr char const* c_str() { return m_buffer; }

    // Constants
    static const size_t npos     = -1;
    static const size_t min_size = 32;

   private:
    char*  m_buffer;
    size_t m_size;

    size_t get_buffer_size(size_t sz) { return (sz - 1) > min_size ? (sz + 1) : min_size; }

    void clean() {
        if (m_buffer != nullptr) { delete[] m_buffer; }
        m_size = 0;
    }
};

}  // namespace std